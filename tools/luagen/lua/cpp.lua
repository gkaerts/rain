Schema = require "Schema"
FileWriter = require "filewriter"

local cpp = {}

cpp.PrimitiveTypeNames = {
    "uint8_t",  -- Uint8
    "uint16_t", -- Uint16
    "uint32_t", -- Uint32
    "uint64_t", -- Uint64
    "int8_t",   -- Int8
    "int16_t",  -- Int16
    "int32_t",  -- Int32
    "int64_t",  -- Int64
    "float",    -- Float
    "double",   -- Double
}

cpp.SpanName = "rn::Span"
cpp.StringName = "std::string_view"
cpp.AdditionalHeaderLines = {
    '#include "common/memory/memory.hpp"',
    '#include "common/memory/span.hpp"',
    '#include "common/memory/string.hpp"'
}
cpp.AssertName = "RN_ASSERT"

function cpp:new(filename, typesToSerialize, namespace, importedFiles)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    self.baseFilename = filename
    self.typesToSerialize = typesToSerialize
    self.namespace = nil
    self.importedFiles = importedFiles

    return self
end

function cpp:openScope(fmt, ...)
    local w = self.writer
    w:writeLn(fmt, ...)
    w:writeLn("{")
    w:indent()
end

function cpp:closeScope(suffix)
    local w = self.writer
    w:unindent()
    if suffix then
        w:writeLn("}" .. suffix)
    else
        w:writeLn("}")
    end
end

function cpp:beginHeader()
    local w = self.writer
    w:writeLn("// This file was auto-generated by luagen")
    w:writeLn("#pragma once")
    w:lineBreak()
    w:writeLn("#include <cstdint>")
    
    for _, v in ipairs(cpp.AdditionalHeaderLines) do
        w:writeLn(v)
    end

    for _, v in ipairs(cpp.importedFiles) do
        w:writeLn("#include \"%s\"", path.getbasename(v) .. "_gen.hpp")
    end

    w:lineBreak()
    w:writeLn("using namespace std::literals;")
    w:lineBreak()
end

function cpp:endHeader()
    local w = self.writer
    if self.namespace then
        self:closeScope()
    end
end

function cpp:writeHeader()
    self.namespace = nil
    self.writer = FileWriter:new(self.baseFilename .. ".hpp")
    local w = self.writer
    self:beginHeader()

    for _, v in pairs(self.typesToSerialize) do
        self:writeType(v.name, v.type)
    end

    self:endHeader()
end

function cpp:openNamespace(namespace)
    local cppNamespace = string.gsub(namespace, "[.]", "::")
    self:openScope("namespace %s", cppNamespace)
    self.namespace = namespace
end

function cpp:writeType(name, type)
    local w = self.writer

    if (type.namespace ~= self.namespace) then
        if (self.namespace) then
            self:closeScope()
            w:lineBreak()
        end
        self:openNamespace(type.namespace)
    end

    if type.layout == Schema.TypeLayout.Enum then
        self:writeEnum(name, type)
    elseif type.layout == Schema.TypeLayout.Struct then
        self:writeStruct(name, type)
    end
end

function cpp:writeEnum(name, type)
    local w = self.writer
    if type.external then
        w:writeLn("enum class %s : %s;", name, self.PrimitiveTypeNames[Schema.PrimitiveType.Uint32])

    else
        self:openScope("enum class %s : %s", name, self.PrimitiveTypeNames[Schema.PrimitiveType.Uint32])

        local enumValue = 0
        local includeCount = true
        for _, v in ipairs(type.elements) do
            if (v.value and v.value ~= enumValue) then
                enumValue = v.value
                includeCount = false
            end

            w:writeLn("%s = %d,", v.name, enumValue)
            enumValue = enumValue + 1
        end

        if includeCount then
            w:lineBreak()
            w:writeLn("Count = %d", enumValue)
        end

        self:closeScope(";")
        w:lineBreak()
    end
end

function cpp:resolveTypeName(typeToResolve)

    local name = ""
    if (typeToResolve.layout == Schema.TypeLayout.String) then
        name = self.StringName

    elseif (typeToResolve.layout == Schema.TypeLayout.Primitive) then
        name = self.PrimitiveTypeNames[typeToResolve.primitive]

    elseif (typeToResolve.layout == Schema.TypeLayout.Span) then
        name = self.SpanName .. "<" .. self:resolveTypeName(typeToResolve.spannedType) .. ">"

    else
        for _, v in ipairs(self.typesToSerialize) do
            if (typeToResolve == v.type) then
                local prefix = ""
                if (typeToResolve.namespace ~= self.namespace) then
                    local cppNamespace = string.gsub(typeToResolve.namespace, "[.]", "::")
                    prefix = cppNamespace .. "::"
                end
                name = prefix .. v.name
                break
            end
        end
    end

    return name
end

function cpp:resolveTypeValue(typeToResolve, typeValue)
    local valueStr = ""
    if typeToResolve.layout == Schema.TypeLayout.Primitive then
        if typeToResolve.primitive == Schema.PrimitiveType.Float then
            valueStr = string.format("%ff", typeValue)

        elseif typeToResolve.primitive == Schema.PrimitiveType.Double then
            valueStr = string.format("%.2f", typeValue)

        else
            valueStr = string.format("%d", typeValue)

        end

    elseif typeToResolve.layout == Schema.TypeLayout.String then
        valueStr = string.format("\"%s\"sv", typeValue)

    elseif typeToResolve.layout == Schema.TypeLayout.Enum then
        local enumName = self:resolveTypeName(typeToResolve)
        valueStr = string.format("%s::%s", enumName, typeValue)


    elseif typeToResolve.layout == Schema.TypeLayout.Struct then
        valueStr = "{";
        for i, f in ipairs(typeToResolve.elements) do
            local innerValue = self:resolveTypeValue(f.type, typeValue[f.name])
            valueStr = string.format("%s .%s = %s", valueStr, f.name, innerValue)

            if i ~= #typeToResolve.elements then
                valueStr = valueStr .. ","
            end
        end
        valueStr = valueStr .. " }"

    elseif typeToResolve.layout == Schema.TypeLayout.Span then
        valueStr = "{";
        for i, v in ipairs(typeValue) do
            local innerValue = self:resolveTypeValue(typeToResolve.spannedType, v)
            valueStr = string.format("%s %s", valueStr, innerValue)
            if i ~= #typeValue then
                valueStr = valueStr .. ","
            end
        end
        valueStr = valueStr .. " }"
    end

    return valueStr
end

function cpp:writeStruct(name, type)
    local w = self.writer

    if type.external then
        w:writeLn("struct %s;", name)
    else
        self:openScope("struct %s", name)

        -- Fields
        for _, v in ipairs(type.elements) do

            local fieldTypeName = self:resolveTypeName(v.type)
            w:writeLn("%s %s;", fieldTypeName, v.name)
        end
        w:lineBreak()

        -- Serialization
        w:writeLn("static %s Deserialize(const %s<const uint8_t>& data, uint64_t& offset, void*(*fnAlloc)(size_t));", name, cpp.SpanName)
        w:writeLn("static uint64_t SerializedSize(const %s& data);", name)
        w:writeLn("static uint64_t Serialize(const %s& data, uint64_t& offset, %s<uint8_t> out);", name, cpp.SpanName)
        
        -- Decoration
        if type.decorations then
            w:lineBreak()
            self:openScope("struct Decorations")
            for _, d in ipairs(type.decorations) do
                local decorationTypeName = ""
                local decorationValue = self:resolveTypeValue(d.type, d.value)
                if d.type.layout == Schema.TypeLayout.Span then
                    -- Treat spans decorations as arrays
                    decorationTypeName = self:resolveTypeName(d.type.spannedType)
                    w:writeLn("static constexpr const %s %s[] = %s;", decorationTypeName, d.name, decorationValue)
                else
                    decorationTypeName = self:resolveTypeName(d.type)
                    w:writeLn("static constexpr const %s %s = %s;", decorationTypeName, d.name, decorationValue)
                end
                
                
            end
            self:closeScope(";")
        end
        self:closeScope(";")
        w:lineBreak()
    end
end

function cpp:beginCPP()
    local w = self.writer
    w:writeLn("// This file was auto-generated by rain_schema")
    w:writeLn("#include \"%s.hpp\"", path.getname(self.baseFilename))
    w:writeLn("#include <cstddef>")
    w:writeLn("#include <string>")
    w:writeLn('#include "luagen/schema.hpp"')

    for _, v in ipairs(cpp.importedFiles) do
        w:writeLn("#include \"%s\"", path.getbasename(v) .. "_gen.hpp")
    end

    w:lineBreak()
    
end

function cpp:endCPP()
    local w = self.writer
    if self.namespace then
        self:closeScope()
    end
end

function cpp:writeCPP()
    self.namespace = nil
    self.writer = FileWriter:new(self.baseFilename .. ".cpp")
    local w = self.writer
    self:beginCPP()

    for _, v in pairs(self.typesToSerialize) do

        if not v.type.external then
            if v.type.layout == Schema.TypeLayout.Struct then

                if (v.type.namespace ~= self.namespace) then
                    if (self.namespace) then
                        self:closeScope()
                        w:lineBreak()
                    end
                    self:openNamespace(v.type.namespace)
                end
                self:writeSerializedSizeDefinition(v.name, v.type)
                w:lineBreak()
                self:writeStructSerializeDefinition(v.name, v.type)
                w:lineBreak()
                self:writeStructDeserializeDefinition(v.name, v.type)
                w:lineBreak()
            end
        end
    end

    self:endCPP()
end

function cpp:writeSerializedSizeDefinition(name, type)

    local w = self.writer
    self:openScope("uint64_t %s::SerializedSize(const %s& data)", name, name)
    w:writeLn("uint64_t size = 0;")
    for _, v in ipairs(type.elements) do
        w:writeLn("size += rn::SerializedSize(data.%s);", v.name)
    end
    w:writeLn("return size;")
    self:closeScope()
end

function cpp:writeStructSerializeDefinition(name, type)
    local w = self.writer

    self:openScope("uint64_t %s::Serialize(const %s& data, uint64_t& offset, %s<uint8_t> out)", name, name, cpp.SpanName)

    -- Determine write size
    w:writeLn("uint64_t EXPECTED_SIZE = %s::SerializedSize(data);", name)
    w:writeLn("%s(out.size_bytes() >= EXPECTED_SIZE);", cpp.AssertName, name)
    w:lineBreak()

    w:writeLn("size_t size = 0;")
    for _, v in ipairs(type.elements) do
        w:writeLn("size += rn::Serialize(out, offset, data.%s);", v.name, v.name)
    end

    w:writeLn("return size;")
    self:closeScope()
end

function cpp:writeStructDeserializeDefinition(name, type)
    local w = self.writer

    self:openScope("%s %s::Deserialize(const %s<const uint8_t>& data, uint64_t& offset, void*(*fnAlloc)(size_t))", name, name, cpp.SpanName)

    self:openScope("return", name)
    for _, v in ipairs(type.elements) do
        local typeName = self:resolveTypeName(v.type)
        w:writeLn(".%s = rn::Deserialize<%s>(data, offset, fnAlloc),", v.name, typeName, v.name)
    end
    self:closeScope(";")

    self:closeScope()
end

return cpp