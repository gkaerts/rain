#define _CRT_SECURE_NO_WARNINGS

#include "build.hpp"
#include "shader.hpp"

#include "common/memory/span.hpp"
#include "common/memory/vector.hpp"

#include <filesystem>
#include <sstream>
#include <regex>

#include <locale>
#include <codecvt>

using namespace Microsoft::WRL;

namespace rn
{
    const TableSchema SHADER_TABLE_SCHEMA = {
        .name = "shader"sv,
        .requiredFields = {
            { .name = "source"sv, .type = toml::node_type::string }
        },
        .optionalFields = {
            { .name = "defines"sv, .type = toml::node_type::array },
            { .name = "include_dirs"sv, .type = toml::node_type::array },
            { .name = "vertex_raster_program"sv, .type = toml::node_type::table },
            { .name = "mesh_raster_program"sv, .type = toml::node_type::table },
            { .name = "compute_program"sv, .type = toml::node_type::table },
            { .name = "ray_tracing_library"sv, .type = toml::node_type::table },
        },
    };

    const TableSchema VERTEX_RASTER_PROGRAM_TABLE_SCHEMA = {
        .name = "vertex_raster_program"sv,
        .requiredFields = {
            { .name = "vertex", .type = toml::node_type::string },
        },
        .optionalFields = {
            { .name = "pixel"sv, .type = toml::node_type::string },
        },
    };

    const TableSchema MESH_RASTER_PROGRAM_TABLE_SCHEMA = {
        .name = "mesh_raster_program"sv,
        .requiredFields = {
            { .name = "amplification", .type = toml::node_type::string },
            { .name = "mesh", .type = toml::node_type::string },
        },
        .optionalFields = {
            { .name = "pixel"sv, .type = toml::node_type::string },
        },
    };

    const TableSchema COMPUTE_PROGRAM_TABLE_SCHEMA = {
        .name = "compute_program"sv,
        .requiredFields = {
            { .name = "compute", .type = toml::node_type::string },
        },
    };

    const TableSchema RAY_TRACING_LIBRARY_TABLE_SCHEMA = {
        .name = "ray_tracing_library"sv,
    };

    

    struct TargetAPIConfig
    {
        std::string extension;
        std::initializer_list<std::wstring> defaultArgs;
    };

    const TargetAPIConfig TARGET_API_CONFIGS[CountOf<TargetAPI>()] = {
        {
            .extension = "d3d12",
            .defaultArgs = { L"-WX", L"-Wno-ignored-attributes", L"-Zi", L"-Qstrip_debug", L"-D _D3D12_=1" },
        },

        // {
        //     .extension = "vulkan",
        //     .defaultArgs = { L"-WX", L"-Wno-ignored-attributes", L"-spirv", L"-fspv-target-env=vulkan1.2", L"-fvk-use-dx-layout", L"-fvk-use-dx-position-w", L"-D API_VULKAN=1" },
        // },
    };

    struct ShaderTargetConfig
    {
        std::wstring target;
        std::string arrayName;
        std::string pdbExtension;
    };

    const ShaderTargetConfig SHADER_TARGET_CONFIGS[CountOf<ShaderTarget>()] = {
        { .target = L"-T vs_6_6",   .arrayName = "VS",  .pdbExtension = "vs"  },
        { .target = L"-T ps_6_6",   .arrayName = "PS",  .pdbExtension = "ps"  },
        { .target = L"-T as_6_6",   .arrayName = "AS",  .pdbExtension = "as"  },
        { .target = L"-T ms_6_6",   .arrayName = "MS",  .pdbExtension = "ms"  },
        { .target = L"-T cs_6_6",   .arrayName = "CS",  .pdbExtension = "cs"  },
        { .target = L"-T lib_6_6",  .arrayName = "LIB", .pdbExtension = "lib" },
    };

    bool WriteShaderBytecodeToHeader(std::string_view file, Span<const ShaderCompilationResult> results, Span<const EntryPoint> entryPoints, TargetAPI api, const DataBuildOptions& options, Vector<std::string>& outFiles)
    {
        std::stringstream str;
        str << "// This file was auto-generated by data_build" << std::endl << std::endl;

        for (const ShaderCompilationResult& compileResult : results)
        {
            IDxcResult* result = compileResult.result.Get();
            if (result)
            {
                const EntryPoint& entryPoint = entryPoints[compileResult.entryPointIdx];
                const ShaderTargetConfig& targetConfig = SHADER_TARGET_CONFIGS[int(entryPoint.target)];

                ComPtr<IDxcBlobUtf8> disasm;
                result->GetOutput(DXC_OUT_DISASSEMBLY, IID_PPV_ARGS(disasm.GetAddressOf()), nullptr);

                ComPtr<IDxcBlob> object;
                result->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(object.GetAddressOf()), nullptr);

                if (!object)
                {
                    return false;
                }

                if (disasm && disasm->GetStringLength() > 0)
                {
                    str << "#if 0" << std::endl << std::endl;
                    str << disasm->GetStringPointer() << std::endl;
                    str << "#endif" << std::endl << std::endl;
                }

                size_t byteCount = object->GetBufferSize();
                size_t columns = 8;
                size_t rows = (byteCount + (columns - 1)) / columns;

                const uint8_t* objBuffer = static_cast<const uint8_t*>(object->GetBufferPointer());

                str << "constexpr const unsigned char " << targetConfig.arrayName << "[] = {" << std::endl;
                str << std::uppercase << std::setfill('0') << std::hex;
                for (size_t row = 0; row < rows; ++row)
                {
                    str << "\t";
                    for (size_t col = 0; col < columns && (row * columns + col) < byteCount; ++col)
                    {
                        str << "0x" << std::setw(2) << uint32_t(objBuffer[row * columns + col]) << ", ";
                    }
                    str << std::endl;
                }
                str << "};" << std::endl << std::endl;
            }
        }

        std::string outString = str.str();
        std::string extension = TARGET_API_CONFIGS[int(api)].extension;
        extension += ".hpp";

        return (WriteDataToDisk(file, extension, options, { reinterpret_cast<const uint8_t*>(outString.c_str()), outString.length()}, true, outFiles) == 0);
    }

    void WriteShaderPDBs(std::string_view file, Span<const ShaderCompilationResult> results, Span<const EntryPoint> entryPoints, TargetAPI api, const DataBuildOptions& options, Vector<std::string>& outFiles)
    {
        for (const ShaderCompilationResult& result : results)
        {
            ComPtr<IDxcBlob> pdb;
            result.result->GetOutput(DXC_OUT_PDB, IID_PPV_ARGS(pdb.GetAddressOf()), nullptr);

            if (!pdb)
            {
                continue;
            }

            const EntryPoint& entryPoint = entryPoints[result.entryPointIdx];


            std::string entryPointName(entryPoint.name.length(), ' ');
            wcstombs(entryPointName.data(), entryPoint.name.data(), entryPoint.name.length());

            std::string extension = SHADER_TARGET_CONFIGS[int(entryPoint.target)].pdbExtension;
            extension += ".";
            extension += entryPointName;
            extension += ".";
            extension += TARGET_API_CONFIGS[int(api)].extension;
            extension += ".pdb";

            WriteDataToDisk(file, extension, options, { static_cast<const uint8_t*>(pdb->GetBufferPointer()), pdb->GetBufferSize()}, false, outFiles);
        }
    }

    void ParseIncludeDependencies(std::string_view file, IDxcCompiler3* compiler, IDxcIncludeHandler* includeHandler, const std::wstring& absoluteSourcePath, const DxcBuffer& sourceBuffer, const Vector<LPCWSTR>& inArgs, Vector<std::string>& outFiles)
    {
        Vector<LPCWSTR> args = inArgs;
        args.push_back(L"-M");
        args.push_back(absoluteSourcePath.c_str());

        ComPtr<IDxcResult> result;
        HRESULT hr = compiler->Compile(&sourceBuffer, args.data(), UINT32(args.size()), includeHandler, IID_PPV_ARGS(result.GetAddressOf()));

        if (result)
        {
            ComPtr<IDxcBlobUtf8> text;
            result->GetOutput(DXC_OUT_TEXT, IID_PPV_ARGS(text.GetAddressOf()), nullptr);

            std::string outString;
            if (text && text->GetStringLength() > 0)
            {
                outString = text->GetStringPointer();
            }

            size_t offset = outString.find_first_of('\n');   // Skip first line containing just the source file. We already capture that elsewhere.
            while (offset != std::string::npos)
            {
                size_t prevOffset = offset;
                offset = outString.find_first_of('\n', offset + 1);

                std::string fileStr = outString.substr(prevOffset + 1, offset - prevOffset - 1);
                if (fileStr.ends_with('\\'))
                {
                    fileStr.resize(fileStr.length() - 1);
                }

                fileStr = std::regex_replace(fileStr, std::regex("^ +| +$|[\r\n]+|( ) +"), "$1");
                if (!fileStr.empty())
                {
                    outFiles.push_back(fileStr);
                }
                
            }
        }
    }

    bool CompileShader(std::string_view file, 
        IDxcCompiler3* compiler, 
        IDxcIncludeHandler* includeHandler, 
        const std::wstring& absoluteSourcePath,
        const DxcBuffer& sourceBuffer, 
        const Vector<LPCWSTR>& inArgs, 
        const EntryPoint& entryPoint, 
        TargetAPI api, 
        ComPtr<IDxcResult>& outResult)
    {
        const ShaderTargetConfig& targetConfig = SHADER_TARGET_CONFIGS[int(entryPoint.target)];

        Vector<LPCWSTR> args = inArgs;
        args.push_back(targetConfig.target.c_str());

        const TargetAPIConfig& apiConfig = TARGET_API_CONFIGS[int(api)];
        for (const std::wstring& arg : apiConfig.defaultArgs)
        {
            args.push_back(arg.c_str());
        }

        if (entryPoint.target != ShaderTarget::Library)
        {
            args.push_back(L"-E");
            args.push_back(entryPoint.name.c_str());
        }

        args.push_back(absoluteSourcePath.c_str());

        ComPtr<IDxcResult> compileResult;
        HRESULT hr = compiler->Compile(&sourceBuffer, args.data(), UINT32(args.size()), includeHandler, IID_PPV_ARGS(compileResult.GetAddressOf()));

        ComPtr<IDxcBlobUtf8> errors;
        compileResult->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(errors.GetAddressOf()), nullptr);

        if (errors && errors->GetStringLength() > 0)
        {
            BuildError(file) << "Failed to compile shader:" << std::endl << errors->GetStringPointer() << std::endl;
            return false;
        }

        outResult = compileResult;

        return true;
    }

    bool CompileShadersForTargetAPI(std::string_view file, 
        const DataBuildOptions& options,
        TargetAPI api,
        const std::wstring& sourceFile,
        Span<const EntryPoint> entryPoints, 
        Span<const std::wstring> defines,
        Span<const std::wstring> includeDirs,
        ScopedVector<ShaderCompilationResult>& results,
        Vector<std::string>& outFiles)
    {
        Vector<LPCWSTR> wArgs;
        wArgs.reserve(defines.size() + includeDirs.size());

        for (const std::wstring& define : defines)
        {
            wArgs.push_back(L"-D ");
            wArgs.push_back(define.c_str());
        }

        for (const std::wstring& dir : includeDirs)
        {
            wArgs.push_back(L"-I ");
            wArgs.push_back(dir.c_str());
        }

        std::filesystem::path sourceShaderPath = MakeRelativeTo(file, sourceFile);

        ComPtr<IDxcUtils> dxcUtils;
        DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(dxcUtils.GetAddressOf()));

        ComPtr<IDxcIncludeHandler> includeHandler;
        dxcUtils->CreateDefaultIncludeHandler(includeHandler.GetAddressOf());

        ComPtr<IDxcBlobEncoding> dxcSource;
        uint32_t codePage = DXC_CP_ACP;
        if (FAILED(dxcUtils->LoadFile(sourceShaderPath.wstring().c_str(), &codePage, dxcSource.GetAddressOf())))
        {
            BuildError(file) << "Failed to load shader source file: '" << sourceShaderPath << "'" << std::endl;
            return false;
        }

        ComPtr<IDxcCompiler3> compiler;
        DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(compiler.GetAddressOf()));

        DxcBuffer sourceBuffer = 
        {
            .Ptr = dxcSource->GetBufferPointer(),
            .Size = dxcSource->GetBufferSize(),
            .Encoding = 0
        };

        uint32_t idx = 0;
        for (const EntryPoint& entryPoint : entryPoints)
        {
            ShaderCompilationResult result =
            {
                .entryPointIdx = idx++
            };

            if (!CompileShader(file, compiler.Get(), includeHandler.Get(), sourceShaderPath.wstring(), sourceBuffer, wArgs, entryPoint, api, result.result))
            {
                return false;
            }

            results.push_back(result);
        }

        ParseIncludeDependencies(file, compiler.Get(), includeHandler.Get(), sourceShaderPath.wstring(), sourceBuffer, wArgs, outFiles);
        WriteShaderPDBs(file, results, entryPoints, api, options, outFiles);

        return true;
    }

    int BuildShader(std::string_view file, toml::parse_result& root, const DataBuildOptions& options, Vector<std::string>& outFiles)
    {
        if (!root["shader"])
        {
            BuildError(file) << "No [shader] table found" << std::endl;
            return 1;
        }

        auto shader = root["shader"];
        if (!ValidateTable(file, *shader.node(), SHADER_TABLE_SCHEMA))
        {
            return 1;
        }

        Vector<std::wstring> wDefines;
        auto defines = shader["defines"];
        if (defines)
        {
            toml::array* defineArr = defines.as_array();
            if (!ValidateArray(file, "defines", defineArr, toml::node_type::string))
            {
                return 1;
            }

            for (auto& el : *defineArr)
            {
                wDefines.push_back(el.value_or(L""));
            }
        }
        
        Vector<std::wstring> wIncludeDirs;
        auto includeDirs = shader["include_dirs"];
        if (includeDirs)
        {
            toml::array* includeArr = includeDirs.as_array();
            if (!ValidateArray(file, "include_dirs", includeArr, toml::node_type::string))
            {
                return 1;
            }

            for (auto& el : *includeArr)
            {
                wIncludeDirs.push_back(el.value_or(L""));
            }
        }

        auto vertexRasterProgram = root["vertex_raster_program"];
        auto meshRasterProgram = root["mesh_raster_program"];
        auto computeProgram = root["compute_program"];
        auto rayTracingLib = root["ray_tracing_library"];

        if (!vertexRasterProgram &&
            !meshRasterProgram &&
            !computeProgram &&
            !rayTracingLib)
        {
            BuildError(file) << "No shader program or library specified." << std::endl;
            return 1;
        }
        
        outFiles.push_back(MakeRelativeTo(file, shader["source"].value_or(""sv)).string());

        Vector<EntryPoint> entryPoints;
        if (vertexRasterProgram)
        {
            if (!ValidateTable(file, *vertexRasterProgram.node(), VERTEX_RASTER_PROGRAM_TABLE_SCHEMA))
            {
                return 1;
            }
       
            entryPoints.push_back({
                .target = ShaderTarget::Vertex,
                .name = vertexRasterProgram["vertex"].value_or(L"")
            });

            if (vertexRasterProgram["pixel"])
            {
                entryPoints.push_back({
                    .target = ShaderTarget::Pixel,
                    .name = vertexRasterProgram["pixel"].value_or(L"")
                });
            }
        }
        else if (meshRasterProgram)
        {
            if (!ValidateTable(file, *meshRasterProgram.node(), MESH_RASTER_PROGRAM_TABLE_SCHEMA))
            {
                return 1;
            }
        
            entryPoints.push_back({
                .target = ShaderTarget::Amplification,
                .name = meshRasterProgram["amplification"].value_or(L"")
            });

            entryPoints.push_back({
                .target = ShaderTarget::Mesh,
                .name = meshRasterProgram["mesh"].value_or(L"")
            });

            if (meshRasterProgram["pixel"])
            {
                entryPoints.push_back({
                    .target = ShaderTarget::Pixel,
                    .name = meshRasterProgram["pixel"].value_or(L"")
                });
            } 
        }
        else if (computeProgram)
        {
            if (!ValidateTable(file, *computeProgram.node(), COMPUTE_PROGRAM_TABLE_SCHEMA))
            {
                return 1;
            }

            entryPoints.push_back({
                .target = ShaderTarget::Compute,
                .name = computeProgram["compute"].value_or(L"")
            });
        }
        else if (rayTracingLib)
        {
            if (!ValidateTable(file, *rayTracingLib.node(), RAY_TRACING_LIBRARY_TABLE_SCHEMA))
            {
                return 1;
            }

            entryPoints.push_back({
                .target = ShaderTarget::Library,
            });
        }

        for (int i = 0; i < CountOf<TargetAPI>(); ++i)
        {
            TargetAPI api = TargetAPI(i);
            
            MemoryScope SCOPE;
            ScopedVector<ShaderCompilationResult> results;
            results.reserve(entryPoints.size());

            if (!CompileShadersForTargetAPI(file, options, api, shader["source"].value_or(L""), entryPoints, wDefines, wIncludeDirs, results, outFiles))
            {
                return 1;
            }

            if (!WriteShaderBytecodeToHeader(file, results, entryPoints, api, options, outFiles))
            {
                return 1;
            }
        }

        return 0;
    }
}
