#include "build.hpp"

#include "common/memory/span.hpp"
#include "common/memory/vector.hpp"

#include <Windows.h>
#include "dxcapi.h"

#include <wrl.h>
#include <filesystem>
#include <sstream>
#include <regex>

using namespace Microsoft::WRL;

namespace rn
{
    const TableSchema SHADER_TABLE_SCHEMA = {
        .name = "shader"sv,
        .requiredFields = {
            { .name = "source"sv, .type = toml::node_type::string }
        },
        .optionalFields = {
            { .name = "defines"sv, .type = toml::node_type::array },
            { .name = "include_dirs"sv, .type = toml::node_type::array },
            { .name = "vertex_raster_program"sv, .type = toml::node_type::table },
            { .name = "mesh_raster_program"sv, .type = toml::node_type::table },
            { .name = "compute_program"sv, .type = toml::node_type::table },
            { .name = "ray_tracing_library"sv, .type = toml::node_type::table },
        },
    };

    const TableSchema VERTEX_RASTER_PROGRAM_TABLE_SCHEMA = {
        .name = "vertex_raster_program"sv,
        .requiredFields = {
            { .name = "vertex", .type = toml::node_type::string },
        },
        .optionalFields = {
            { .name = "pixel"sv, .type = toml::node_type::string },
        },
    };

    const TableSchema MESH_RASTER_PROGRAM_TABLE_SCHEMA = {
        .name = "mesh_raster_program"sv,
        .requiredFields = {
            { .name = "amplification", .type = toml::node_type::string },
            { .name = "mesh", .type = toml::node_type::string },
        },
        .optionalFields = {
            { .name = "pixel"sv, .type = toml::node_type::string },
        },
    };

    const TableSchema COMPUTE_PROGRAM_TABLE_SCHEMA = {
        .name = "compute_program"sv,
        .requiredFields = {
            { .name = "compute", .type = toml::node_type::string },
        },
    };

    const TableSchema RAY_TRACING_LIBRARY_TABLE_SCHEMA = {
        .name = "ray_tracing_library"sv,
    };

    enum class TargetAPI : uint32_t
    {
        D3D12 = 0,
        //Vulkan = 1,
        Count
    };

    struct TargetAPIConfig
    {
        std::string extension;
        std::initializer_list<std::wstring> defaultArgs;
    };

    const TargetAPIConfig TARGET_API_CONFIGS[CountOf<TargetAPI>()] = {
        {
            .extension = "d3d12",
            .defaultArgs = { L"-WX", L"-Wno-ignored-attributes", L"-Zi", L"-Qstrip_debug", L"-D _D3D12_=1" },
        },

        // {
        //     .extension = "vulkan",
        //     .defaultArgs = { L"-WX", L"-Wno-ignored-attributes", L"-spirv", L"-fspv-target-env=vulkan1.2", L"-fvk-use-dx-layout", L"-fvk-use-dx-position-w", L"-D API_VULKAN=1" },
        // },
    };

    enum class ShaderTarget : uint32_t
    {
        Vertex,
        Pixel,
        Amplification,
        Mesh,
        Compute,
        Library,
        Count
    };

    struct ShaderTargetConfig
    {
        std::wstring target;
        std::string arrayName;
        std::string pdbExtension;
    };

    const ShaderTargetConfig SHADER_TARGET_CONFIGS[CountOf<ShaderTarget>()] = {
        { .target = L"-T vs_6_6",   .arrayName = "VS",  .pdbExtension = "vs"  },
        { .target = L"-T ps_6_6",   .arrayName = "PS",  .pdbExtension = "ps"  },
        { .target = L"-T as_6_6",   .arrayName = "AS",  .pdbExtension = "as"  },
        { .target = L"-T ms_6_6",   .arrayName = "MS",  .pdbExtension = "ms"  },
        { .target = L"-T cs_6_6",   .arrayName = "CS",  .pdbExtension = "cs"  },
        { .target = L"-T lib_6_6",  .arrayName = "LIB", .pdbExtension = "lib" },
    };

    struct ShaderCompilerInputs
    {
        std::string_view sourceFile;
    };

    struct ShaderCompilationResult
    {
        ShaderTarget target;
        ComPtr<IDxcResult> result;
    };

    bool WriteShaderBytecodeToHeader(std::string_view file, Span<ShaderCompilationResult> results, TargetAPI api, const DataBuildOptions& options, Vector<std::string>& outFiles)
    {
        std::stringstream str;
        str << "// This file was auto-generated by data_build" << std::endl << std::endl;

        for (const ShaderCompilationResult& compileResult : results)
        {
            IDxcResult* result = compileResult.result.Get();
            if (result)
            {
                const ShaderTargetConfig& targetConfig = SHADER_TARGET_CONFIGS[int(compileResult.target)];

                ComPtr<IDxcBlobUtf8> disasm;
                result->GetOutput(DXC_OUT_DISASSEMBLY, IID_PPV_ARGS(disasm.GetAddressOf()), nullptr);

                ComPtr<IDxcBlob> object;
                result->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(object.GetAddressOf()), nullptr);

                if (!object)
                {
                    return false;
                }

                if (disasm && disasm->GetStringLength() > 0)
                {
                    str << "#if 0" << std::endl << std::endl;
                    str << disasm->GetStringPointer() << std::endl;
                    str << "#endif" << std::endl << std::endl;
                }

                size_t byteCount = object->GetBufferSize();
                size_t columns = 8;
                size_t rows = (byteCount + (columns - 1)) / columns;

                const uint8_t* objBuffer = static_cast<const uint8_t*>(object->GetBufferPointer());

                str << "constexpr const unsigned char " << targetConfig.arrayName << "[] = {" << std::endl;
                str << std::uppercase << std::setfill('0') << std::hex;
                for (size_t row = 0; row < rows; ++row)
                {
                    str << "\t";
                    for (size_t col = 0; col < columns && (row * columns + col) < byteCount; ++col)
                    {
                        str << "0x" << std::setw(2) << uint32_t(objBuffer[row * columns + col]) << ", ";
                    }
                    str << std::endl;
                }
                str << "};" << std::endl << std::endl;
            }
        }

        std::string outString = str.str();
        std::string extension = TARGET_API_CONFIGS[int(api)].extension;
        extension += ".hpp";

        return (WriteDataToDisk(file, extension, options, { reinterpret_cast<const uint8_t*>(outString.c_str()), outString.length()}, true, outFiles) == 0);
    }

    void WriteShaderPDBs(std::string_view file, Span<ShaderCompilationResult> results, TargetAPI api, const DataBuildOptions& options, Vector<std::string>& outFiles)
    {
        for (const ShaderCompilationResult& result : results)
        {
            ComPtr<IDxcBlob> pdb;
            result.result->GetOutput(DXC_OUT_PDB, IID_PPV_ARGS(pdb.GetAddressOf()), nullptr);

            if (!pdb)
            {
                continue;
            }

            std::string extension = SHADER_TARGET_CONFIGS[int(result.target)].pdbExtension;
            extension += ".";
            extension += TARGET_API_CONFIGS[int(api)].extension;
            extension += ".pdb";

            WriteDataToDisk(file, extension, options, { static_cast<const uint8_t*>(pdb->GetBufferPointer()), pdb->GetBufferSize()}, false, outFiles);
        }
    }

    std::filesystem::path SourcePath(std::string_view file, std::string_view sourceFile)
    {
        std::filesystem::path buildFilePath = file;
        std::filesystem::path relBuildFileDirectory = buildFilePath.relative_path().parent_path();
        return relBuildFileDirectory / sourceFile;
    }

    void ParseIncludeDependencies(std::string_view file, IDxcCompiler3* compiler, const DxcBuffer& sourceBuffer, const Vector<LPCWSTR>& inArgs, Vector<std::string>& outFiles)
    {
        std::stringstream str;

        Vector<LPCWSTR> args = inArgs;
        args.push_back(L"-M");

        ComPtr<IDxcResult> result;
        HRESULT hr = compiler->Compile(&sourceBuffer, args.data(), UINT32(args.size()), nullptr, IID_PPV_ARGS(result.GetAddressOf()));

        if (result)
        {
            ComPtr<IDxcBlobUtf8> text;
            result->GetOutput(DXC_OUT_TEXT, IID_PPV_ARGS(text.GetAddressOf()), nullptr);

            if (text && text->GetStringLength() > 0)
            {
                str << text->GetStringPointer() << std::endl;
            }

            std::string outString = str.str();

            size_t offset = outString.find_first_of('\n');   // Skip first line containing just the source file. We already capture that elsewhere.
            while (offset != std::string::npos)
            {
                size_t prevOffset = offset;
                offset = outString.find_first_of('\n', offset + 1);

                std::string fileStr = outString.substr(prevOffset + 1, offset - prevOffset - 1);
                if (fileStr.ends_with('\\'))
                {
                    fileStr.resize(fileStr.length() - 1);
                }

                fileStr = std::regex_replace(fileStr, std::regex("^ +| +$|[\r\n]+|( ) +"), "$1");
                if (!fileStr.empty())
                {
                    outFiles.push_back(SourcePath(file, fileStr).string());
                }
                
            }
        }
    }

    struct EntryPoint
    {
        ShaderTarget target;
        std::wstring name;
    };

    bool CompileShader(std::string_view file, IDxcCompiler3* compiler, IDxcIncludeHandler* includeHandler, const DxcBuffer& sourceBuffer, const Vector<LPCWSTR>& inArgs, const EntryPoint& entryPoint, TargetAPI api, ShaderCompilationResult& outResult)
    {
        const ShaderTargetConfig& targetConfig = SHADER_TARGET_CONFIGS[int(entryPoint.target)];

        Vector<LPCWSTR> args = inArgs;
        args.push_back(targetConfig.target.c_str());

        const TargetAPIConfig& apiConfig = TARGET_API_CONFIGS[int(api)];
        for (const std::wstring& arg : apiConfig.defaultArgs)
        {
            args.push_back(arg.c_str());
        }

        if (entryPoint.target != ShaderTarget::Library)
        {
            args.push_back(L"-E");
            args.push_back(entryPoint.name.c_str());
        }


        ComPtr<IDxcResult> compileResult;
        HRESULT hr = compiler->Compile(&sourceBuffer, args.data(), UINT32(args.size()), includeHandler, IID_PPV_ARGS(compileResult.GetAddressOf()));

        ComPtr<IDxcBlobUtf8> errors;
        compileResult->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(errors.GetAddressOf()), nullptr);

        if (errors && errors->GetStringLength() > 0)
        {
            BuildError(file) << "Failed to compile shader:" << std::endl << errors->GetStringPointer() << std::endl;
            return false;
        }

        outResult = {
            .target = entryPoint.target,
            .result = compileResult,
        };

        return true;
    }

    int BuildShader(std::string_view file, toml::parse_result& root, const DataBuildOptions& options, Vector<std::string>& outFiles)
    {
        if (!root["shader"])
        {
            BuildError(file) << "No [shader] table found" << std::endl;
            return 1;
        }

        auto shader = root["shader"];
        if (!ValidateTable(file, *shader.node(), SHADER_TABLE_SCHEMA))
        {
            return 1;
        }

        ShaderCompilerInputs inputs = {
            .sourceFile = shader["source"].value_or(""sv)
        };

        Vector<std::wstring> wArgs;
        auto defines = shader["defines"];
        if (defines)
        {
            toml::array* defineArr = defines.as_array();
            if (!ValidateArray(file, "defines", defineArr, toml::node_type::string))
            {
                return 1;
            }

            for (auto& el : *defineArr)
            {
                std::wstring arg = L"-D " + el.value_or(L"");
                wArgs.push_back(el.value_or(L""));
            }
        }
        wArgs.push_back(shader["source"].value_or(L""));

        auto includeDirs = shader["include_dirs"];
        if (includeDirs)
        {
            toml::array* includeArr = includeDirs.as_array();
            if (!ValidateArray(file, "include_dirs", includeArr, toml::node_type::string))
            {
                return 1;
            }

            for (auto& el : *includeArr)
            {
                std::wstring arg = L"-I " + el.value_or(L"");
                wArgs.push_back(arg);
            }
        }

        auto vertexRasterProgram = root["vertex_raster_program"];
        auto meshRasterProgram = root["mesh_raster_program"];
        auto computeProgram = root["compute_program"];
        auto rayTracingLib = root["ray_tracing_library"];

        if (!vertexRasterProgram &&
            !meshRasterProgram &&
            !computeProgram &&
            !rayTracingLib)
        {
            BuildError(file) << "No shader program or library specified." << std::endl;
            return 1;
        }

        std::filesystem::path sourceShaderPath = SourcePath(file, inputs.sourceFile);

        ComPtr<IDxcUtils> dxcUtils;
        DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(dxcUtils.GetAddressOf()));

        ComPtr<IDxcIncludeHandler> includeHandler;
        dxcUtils->CreateDefaultIncludeHandler(includeHandler.GetAddressOf());

        ComPtr<IDxcBlobEncoding> dxcSource;
        uint32_t codePage = DXC_CP_ACP;
        if (FAILED(dxcUtils->LoadFile(sourceShaderPath.wstring().c_str(), &codePage, dxcSource.GetAddressOf())))
        {
            BuildError(file) << "Failed to load shader source file: '" << sourceShaderPath << "'" << std::endl;
            return 1;
        }

        outFiles.push_back(sourceShaderPath.string());

        ComPtr<IDxcCompiler3> compiler;
        DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(compiler.GetAddressOf()));

        DxcBuffer sourceBuffer = 
        {
            .Ptr = dxcSource->GetBufferPointer(),
            .Size = dxcSource->GetBufferSize(),
            .Encoding = 0
        };

        Vector<LPCWSTR> wArgPtrs;
        for (std::wstring& str : wArgs)
        {
            wArgPtrs.push_back(str.data());
        }

        Vector<EntryPoint> entryPoints;
        if (vertexRasterProgram)
        {
            if (!ValidateTable(file, *vertexRasterProgram.node(), VERTEX_RASTER_PROGRAM_TABLE_SCHEMA))
            {
                return 1;
            }
       
            entryPoints.push_back({
                .target = ShaderTarget::Vertex,
                .name = vertexRasterProgram["vertex"].value_or(L"")
            });

            if (vertexRasterProgram["pixel"])
            {
                entryPoints.push_back({
                    .target = ShaderTarget::Pixel,
                    .name = vertexRasterProgram["pixel"].value_or(L"")
                });
            }
        }
        else if (meshRasterProgram)
        {
            if (!ValidateTable(file, *meshRasterProgram.node(), MESH_RASTER_PROGRAM_TABLE_SCHEMA))
            {
                return 1;
            }
        
            entryPoints.push_back({
                .target = ShaderTarget::Amplification,
                .name = meshRasterProgram["amplification"].value_or(L"")
            });

            entryPoints.push_back({
                .target = ShaderTarget::Mesh,
                .name = meshRasterProgram["mesh"].value_or(L"")
            });

            if (meshRasterProgram["pixel"])
            {
                entryPoints.push_back({
                    .target = ShaderTarget::Pixel,
                    .name = meshRasterProgram["pixel"].value_or(L"")
                });
            } 
        }
        else if (computeProgram)
        {
            if (!ValidateTable(file, *computeProgram.node(), COMPUTE_PROGRAM_TABLE_SCHEMA))
            {
                return 1;
            }

            entryPoints.push_back({
                .target = ShaderTarget::Compute,
                .name = computeProgram["compute"].value_or(L"")
            });
        }
        else if (rayTracingLib)
        {
            if (!ValidateTable(file, *rayTracingLib.node(), RAY_TRACING_LIBRARY_TABLE_SCHEMA))
            {
                return 1;
            }

            entryPoints.push_back({
                .target = ShaderTarget::Library,
            });
        }

        for (int i = 0; i < CountOf<TargetAPI>(); ++i)
        {
            TargetAPI api = TargetAPI(i);
            
            MemoryScope SCOPE;
            ScopedVector<ShaderCompilationResult> results;
            results.reserve(entryPoints.size());

            for (const EntryPoint& entryPoint : entryPoints)
            {
                ShaderCompilationResult result;
                if (!CompileShader(file, compiler.Get(), includeHandler.Get(), sourceBuffer, wArgPtrs, entryPoint, api, result))
                {
                    return 1;
                }

                results.push_back(result);
            }


            if (!WriteShaderBytecodeToHeader(file, results, api, options, outFiles))
            {
                return 1;
            }

            ParseIncludeDependencies(file, compiler.Get(), sourceBuffer, wArgPtrs, outFiles);
            WriteShaderPDBs(file, results, api, options, outFiles);
        }

        return 0;
    }
}
